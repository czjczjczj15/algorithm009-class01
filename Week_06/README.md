学习笔记
如果改变的状态都是在参数上面，因为递归调用的时候，这个参数是会被复制的，
如果是简单变量的话，就不需要回复这个过程。

分治是递归的一种特殊形式。
1. 人肉递归低效，很累。
2. 找到最近最简方法，将其拆解成可重复解决的问题。
3. 数学归纳法思维（抵制人肉递归的诱惑）
本质：寻找重复性 --> 计算机指令集

动态规划：
有最优子结构，所以在中间的每一步就不需要把所有的状态都储存下来，只需要存最优的状态。
当然还要证明，如果每一步都存着最优的值，最后可以推导出一个全局的最优的值。

动态规划 和 递归或者分治 没有根本上的区别（关键看有无最优的子结构）
共性：找到重复子问题
差异性：最优子结构、中途可以淘汰次优解

例子1：斐波拉系数：
用傻递归来求解，时间复杂度是指数级的
fib(n) = fib(n-1) + fib(n-2)
fib(0) = 0
fib(1) = 1

如何改变时间复杂度？我们可以用缓存，在python里我们可以用LRU Cache之类的。
这种方法叫做记忆化搜索。
我们可以存在一个叫memo的数组里，不然的话每次计算比如fib(3)，都要从fib(1)，fib(2)开始算。
如果用了memo，时间复杂度从O(n^2)降为O(n)

自顶向上Bottome up
F[n] = F[n-1] + F[n-2]

初级可以从分治和记忆化开始，到熟练的时候直接从自底向上开始写for loop

复杂一点的DP：
１.维度变化了：状态有时候是二位的，或者三维的。
２.中间会有取舍最优子结构。

动态规划关键点
1. 最优子结构 opt[n] = best_of(opt[n-1], opt[n-2], …) （有时候是直接累加，有时候是加最大值，有时候加最小值）
2. 储存中间状态：opt[i] 
3. 递推公式（美其名曰：状态转移方程或者 DP 方程） 
    Fib: opt[i] = opt[n-1] + opt[n-2] 
    二维路径：opt[i,j] = opt[i+1][j] + opt[i][j+1] (且判断a[i,j]是否空地）

动态规划注意事项：
1. 有时候要初始化0，比如1143.最长公共子序列，322零钱兑换等。
2. 注意数据越界的问题

动态规划小结：
1.打破自己的思维 惯性，形成机器思维，找重复性。如用简单的for loop, if else, 递归。
2.理解复杂逻辑的关键








